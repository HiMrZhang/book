# volatile剖析

## volatile有哪些特性呢？

1.原子性：volatile修饰的long、double，读/写操作是原子的。对于64位的long和double，如果没有被volatile修饰，在32位操作系统中long和double的读/写操作通过两次32位读/写操作完成，两次操作之间可发生中断。

2.可见性：线程修改了volatile变量的值后，其他线程立即可以感知到这个值的修改。

3.避免重排序。

## 为什么会导致可见性问题呢？JMM\(java内存模型\)

![](/assets/091134177063947.jpg)

线程、主内存和工作内存的交互关系如下图所示。java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，从而导致不同进程之间可见性的问题。

注意：

* 此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享，不存在可见性问题。

* 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。

## JMM内存间如何交互？

关于主内存与工作内存之间的具体交互协议，即一个变量如何从主内存拷贝到工作内存、如何从工作内存同步到主内存之间的实现细节，Java内存模型定义了以下八种原子操作来完成：

* lock（锁定）：作用于主内存的变量，把一个变量标识为一条线程独占状态。

* unlock（解锁）：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。

* read（读取）：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用

* load（载入）：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。

* use（使用）：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。

* assign（赋值）：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。

* store（存储）：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。

* write（写入）：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。

如果要把一个变量从主内存中复制到工作内存，就需要按顺寻地执行read和load操作，如果把变量从工作内存中同步回主内存中，就要按顺序地执行store和write操作。Java内存模型只要求上述操作必须按顺序执行，而没有保证必须是连续执行。也就是read和load之间，store和write之间是可以插入其他指令的，如对主内存中的变量a、b进行访问时，可能的顺序是read a，read b，load b， load a。Java内存模型还规定了在执行上述八种基本操作时，必须满足如下规则：

* 不允许read和load、store和write操作之一单独出现

* 不允许一个线程丢弃它的最近assign的操作，即变量在工作内存中改变了之后必须同步到主内存中。

* 不允许一个线程无原因地（没有发生过任何assign操作）把数据从工作内存同步回主内存中。

* 一个新的变量只能在主内存中诞生，不允许在工作内存中直接使用一个未被初始化（load或assign）的变量。即就是对一个变量实施use和store操作之前，必须先执行过了assign和load操作。

* 一个变量在同一时刻只允许一条线程对其进行lock操作，lock和unlock必须成对出现

* 如果对一个变量执行lock操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前需要重新执行load或assign操作初始化变量的值

* 如果一个变量事先没有被lock操作锁定，则不允许对它执行unlock操作；也不允许去unlock一个被其他线程锁定的变量。

* 对一个变量执行unlock操作之前，必须先把此变量同步到主内存中（执行store和write操作）。

Tips：在字节码层次提供了monitorenter和monitorexit来隐式的完成lock和unlock操作，反映到java代码中就是同步代码块了 synchronize。

## volatile如何保证内存可见性？

java内存模型中对volatile变量定义的特殊规则：

* read、load、use 必须一起出现，保证每次使用工作内存中的变量时，都必须从主内存刷新最新的值，以便能看见其他线程对变量所做的修改。

* assign、store、write 必须一起出现，保证每次修改都立刻同步到主内存中。

* 对两个不同变量的use或assign操作顺序，要和对这两个变量的read或write操作顺序相同（禁止指令重排序）。

## 哪些阶段会发生指令重排？

![](/assets/20181128180644795.png)

在执行程序时为了提高性能，编译器和处理器经常会对指令进行重排序。从硬件架构上来说，指令重排序是指CPU采用了允许将多条指令不按照程序规定的顺序，分开发送给各个相应电路单元处理，而不是指令任意重排。重排序分成三种类型：

* 编译器优化的重排序。编译器在不改变单线程程序语义放入前提下，可以重新安排语句的执行顺序。

* 指令级并行的重排序。现代处理器采用了指令级并行技术来将多条指令重叠执行。如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序。

* 内存系统的重排序。由于处理器使用缓存和读写缓冲区，这使得加载和存储操作看上去可能是在乱序执行。

## volatile如何避免指令重排？

java编译器会在生成指令系列时在适当的位置会插入内存屏障指令来禁止特定类型的处理器重排序。为了实现volatile的内存语义，JMM会限制特定类型的编译器和处理器重排序，JMM会针对编译器制定volatile重排序规则表：![](/assets/2615789-fa62c72e7ec4ccb0.png)（1）如果第一个操作为普通变量对写，第二个操作为volatile变量的写，不能发生重排序。

（2）如果第一个操作为volatile变量读，无论第二个操作是什么都不能发生重排序。

（3）如果第一个操作为volatile变量写，第二个操作为volatile变量读/写，不能发生重排下。

JMM内存屏障：

![](/assets/2615789-27cf04634cbdf284.png)

volatile关键字通过提供“内存屏障”的方式来防止指令被重排序，为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，Java内存模型采取保守策略。下面是基于保守策略的JMM内存屏障插入策略：

* 在每个volatile写操作的前面插入一个StoreStore屏障。

* 在每个volatile写操作的后面插入一个StoreLoad屏障。

* 在每个volatile读操作的后面插入一个LoadLoad屏障。

* 在每个volatile读操作的后面插入一个LoadStore屏障。



