# volatile剖析

## volatile有哪些特性呢？

1.原子性：volatile修饰的long、double，读/写操作是原子的。对于64位的long和double，如果没有被volatile修饰，在32位操作系统中long和double的读/写操作通过两次32位读/写操作完成，两次操作之间可能发生线程切换。

2.可见性：线程修改了volatile变量的值后，其他线程立即可以感知到这个值的修改。

3.重排序：![](/assets/2615789-fa62c72e7ec4ccb0.png)（1）如果第一个操作为普通变量对写，第二个操作为volatile变量的写，不能发生重排序。

（2）如果第一个操作为volatile变量读，无论第二个操作是什么都不能发生重排序。

（3）如果第一个操作为volatile变量写，第二个操作为volatile变量读/写，不能发生重排下。

## 为什么会导致可见性问题呢？JMM\(java内存模型\)

![](/assets/091134177063947.jpg)

线程、主内存和工作内存的交互关系如下图所示。java内存模型中规定了所有的变量都存储在主内存中，每条线程还有自己的工作内存，线程的工作内存中保存了该线程使用到的变量到主内存副本拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同线程之间无法直接访问对方工作内存中的变量，线程间变量值的传递均需要在主内存来完成，从而导致不同进程之间可见性的问题。

注意：

* 此处的变量与Java编程时所说的变量不一样，指包括了实例字段、静态字段和构成数组对象的元素，但是不包括局部变量与方法参数，后者是线程私有的，不会被共享，不存在可见性问题。

* 这里的主内存、工作内存与Java内存区域的Java堆、栈、方法区不是同一层次内存划分。

## volatile如何保证内存可见性？

实际上这组happens-before规则定义了操作之间的内存可见性，如果A操作happens-before B操作，那么A操作的执行结果（比如对变量的写入）必定在执行B操作时可见。

JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。

内存屏障（memory barrier） 是一个CPU指令。基本上，它是这样一条指令： a\) 确保一些特定操作执行的顺序； b\) 影响一些数据的可见性\(可能是某些指令执行后的结果\)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

