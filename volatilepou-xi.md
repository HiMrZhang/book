# volatile剖析

## volatile有哪些特性呢？

1.原子性：volatile修饰的long、double，读/写操作是原子的。对于64位的long和double，如果没有被volatile修饰，在32位操作系统中long和double的读/写操作通过两次32位读/写操作完成，两次操作之间可能发生线程切换。

2.可见性：线程修改了volatile变量的值后，其他线程立即可以感知到这个值的修改。

3.重排序：![](/assets/2615789-fa62c72e7ec4ccb0.png)（1）如果第一个操作为普通变量对写，第二个操作为volatile变量的写，不能发生重排序。

（2）如果第一个操作为volatile变量读，无论第二个操作是什么都不能发生重排序。

（3）如果第一个操作为volatile变量写，第二个操作为volatile变量读/写，不能发生重排下。

## 为什么会导致可见性问题呢？JMM\(java内存模型\)





实际上这组happens-before规则定义了操作之间的内存可见性，如果A操作happens-before B操作，那么A操作的执行结果（比如对变量的写入）必定在执行B操作时可见。

JMM 内部的实现通常是依赖于所谓的内存屏障，通过禁止某些重排序的方式，提供内存可见性保证，也就是实现了各种 happen-before 规则。

内存屏障（memory barrier） 是一个CPU指令。基本上，它是这样一条指令： a\) 确保一些特定操作执行的顺序； b\) 影响一些数据的可见性\(可能是某些指令执行后的结果\)。编译器和CPU可以在保证输出结果一样的情况下对指令重排序，使性能得到优化。插入一个内存屏障， 相当于告诉CPU和编译器先于这个命令的必须先执行，后于这个命令的必须后执行。内存屏障另一个作用是强制更新一次不同CPU的缓存。例如，一个写屏障会 把这个屏障前写入的数据刷新到缓存，这样任何试图读取该数据的线程将得到最新值，而不用考虑到底是被哪个cpu核心或者哪颗CPU执行的。

